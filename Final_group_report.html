<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Final Group Report</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Final_group_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="Final_group_report_files/libs/quarto-html/quarto.js"></script>
<script src="Final_group_report_files/libs/quarto-html/popper.min.js"></script>
<script src="Final_group_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Final_group_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="Final_group_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Final_group_report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Final_group_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Final_group_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Final_group_report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#executive-summary" id="toc-executive-summary" class="nav-link active" data-scroll-target="#executive-summary"><span class="header-section-number">1</span> Executive Summary</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">2</span> Introduction</a></li>
  <li><a href="#method-overview" id="toc-method-overview" class="nav-link" data-scroll-target="#method-overview"><span class="header-section-number">3</span> Method Overview</a></li>
  <li><a href="#data-collection-and-preprocessing" id="toc-data-collection-and-preprocessing" class="nav-link" data-scroll-target="#data-collection-and-preprocessing"><span class="header-section-number">4</span> Data Collection and Preprocessing</a>
  <ul class="collapse">
  <li><a href="#data-overview" id="toc-data-overview" class="nav-link" data-scroll-target="#data-overview"><span class="header-section-number">4.1</span> 2.1 Data Overview</a></li>
  <li><a href="#data-preprocessing" id="toc-data-preprocessing" class="nav-link" data-scroll-target="#data-preprocessing"><span class="header-section-number">4.2</span> 2.2 Data Preprocessing</a></li>
  <li><a href="#feature-engineering" id="toc-feature-engineering" class="nav-link" data-scroll-target="#feature-engineering"><span class="header-section-number">4.3</span> 2.3 Feature Engineering</a></li>
  </ul></li>
  <li><a href="#model-candidates" id="toc-model-candidates" class="nav-link" data-scroll-target="#model-candidates"><span class="header-section-number">5</span> Model Candidates</a></li>
  <li><a href="#model-building" id="toc-model-building" class="nav-link" data-scroll-target="#model-building"><span class="header-section-number">6</span> Model Building</a>
  <ul class="collapse">
  <li><a href="#egarch-model" id="toc-egarch-model" class="nav-link" data-scroll-target="#egarch-model"><span class="header-section-number">6.1</span> EGARCH model</a></li>
  </ul></li>
  <li><a href="#evaluation-metrics" id="toc-evaluation-metrics" class="nav-link" data-scroll-target="#evaluation-metrics"><span class="header-section-number">7</span> Evaluation Metrics</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results"><span class="header-section-number">8</span> Results</a></li>
  <li><a href="#hyperparameter-tuning" id="toc-hyperparameter-tuning" class="nav-link" data-scroll-target="#hyperparameter-tuning"><span class="header-section-number">9</span> Hyperparameter Tuning</a></li>
  <li><a href="#feature-selection" id="toc-feature-selection" class="nav-link" data-scroll-target="#feature-selection"><span class="header-section-number">10</span> Feature Selection</a></li>
  <li><a href="#robustness-check-and-generalisability" id="toc-robustness-check-and-generalisability" class="nav-link" data-scroll-target="#robustness-check-and-generalisability"><span class="header-section-number">11</span> Robustness Check and Generalisability</a></li>
  <li><a href="#appendix" id="toc-appendix" class="nav-link" data-scroll-target="#appendix"><span class="header-section-number">12</span> Appendix</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Group Report</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p align="center">
<img src="gradient-stock-market-concept/6257814.jpg" width="600">
</p>
<section id="executive-summary" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="executive-summary"><span class="header-section-number">1</span> Executive Summary</h2>
<p>For decades, forecasting volatility has been the domain of models such as EGARCH, which are statistically elegant but unsuited to the non-linear speed and structure of high-frequency trading. As real-time decisions become more crucial, relying solely on historical prices is no longer sufficient. This project asks a simple but ambitious question: What if we could forecast volatility using the real-time heartbeat of the market itself? Leveraging second-by-second order book data, we explore whether machine learning models can detect early signals of market stress—before it’s too late. We built and compared several models—including LightGBM and XGBoost—using engineered features such as bid-ask spreads, price deltas, and imbalance velocity. These models were trained to predict realised volatility over short horizons. At the heart of our work is EchoVol20, a real-time volatility forecasting dashboard that merges finance, machine learning, and interactive design. Traders can upload data, explore hidden patterns in bid-ask dynamics, and receive actionable volatility forecasts classified into normal, high, or extreme regimes. A built-in risk calculator even translates these forecasts into position sizing and exposure metrics.</p>
<p>But how well does it perform? Which features matter most? And can it adapt to different market regimes? These are questions we tackle head-on through rigorous experimentation and robust design choices.</p>
</section>
<section id="introduction" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="introduction"><span class="header-section-number">2</span> Introduction</h2>
<p>Volatility—defined as the degree of variation in asset returns—is not merely a statistical measure but a force that shapes derivative pricing, portfolio allocations, and risk management (Bhambu et al, 2025). Yet, despite its centrality, volatility remains notoriously difficult to predict, particularly in today’s high-frequency trading (HFT) ecosystems, where price movements unfold in miliseconds and traditional models struggle to adapt. The stakes of forecasting errors are starkly real: in 2024, a sudden spike in the CBOE Volatility Index (VIX) triggered the collapse of multiply short-volatility ETFs (Exchange-Traded Funds), erasing over $4 billion in value within days (Mackenzie, 2024). Such episodes underscore the immense impact of inaccurate volatility predictions and failure to anticipate abrupt market shifts.</p>
<p>For decades, volatility forecasting has been dominated by models in the Generalised Autoregressive Conditional Heteroskedasticity (GARCH) family. These models, introduced by Engle and Bollerslev, model time-varying volatility by capturing patterns in historical return series. Extensions like the Exponential GARCH (EGARCH) improved upon this by accounting for the leverage effect—the empirical tendency for negative returns to increase future volatility more than positive ones of the same magnitude [Jonathan, 2025]. Yet, these models still rely on weak stationarity and linear relationships, leaving them ill-equipped for adapting to the rapid, non-linear patterns found in modern high-frequency markets (Mohammed, Mudhir, 2020).</p>
<p>The rise of HFT has transformed volatility into a high-resolution puzzle. Today’s order books—streaming real-time data on liquidity, order flow imbalances, and spread dynamics—contain latent signals that often precede volatility shocks (Ashwin et al., 2012). Machine learning (ML) models, with their capacity to decode complex, high-dimensional patterns, offer a compelling alternative. But can they truly outperform econometric benchmarks in practice?</p>
<p>The core question we ask is:</p>
<p><b> Do machine learning models, trained on high-frequency order book data, deliver more accurate and timely short-term volatility forecasts than traditional econometric approaches? </b></p>
<p>To address this, we conduct a rigorous comparative analysis of:</p>
<ul>
<li><p>EGARCH: The industry standard for asymmetric volatility modeling.</p></li>
<li><p>Gradient Boosting Models (LightGBM, XGBoost): Ensemble machine learning algorithms designed to capture complex, nonlinear feature interactions in noisy, high-frequency data.</p></li>
<li></li>
</ul>
<p>As markets grow increasingly algorithmic, the ability to anticipate volatility in real time is no longer just profitable—it is a safeguard against systemic instability. Our findings aim to inform quants, asset managers, and regulators alike, bridging the gap between econometric theory and the demands of machine-driven finance.</p>
</section>
<section id="method-overview" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="method-overview"><span class="header-section-number">3</span> Method Overview</h2>
</section>
<section id="data-collection-and-preprocessing" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="data-collection-and-preprocessing"><span class="header-section-number">4</span> Data Collection and Preprocessing</h2>
<section id="data-overview" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="data-overview"><span class="header-section-number">4.1</span> 2.1 Data Overview</h3>
<p><b>Primary Training Dataset: High-Frequency Anonymized Order Book Data</b></p>
<p>The foundational dataset used in this study comprises high-frequency order book records for 126 anonymized stocks. Each record is identified by a unique <code>time_id</code>, representing an unspecified temporal segment within the trading day. These <code>time_id</code>s are not sequential, nor tied to actual timestamps, precluding any direct temporal aggregation across them for time-series modeling.</p>
<p>Within each <code>time_id</code>, order book snapshots are recorded at second-level resolution for up to 600 seconds, simulating a 10-min trading window. However, not all seconds are observed, indicating intermittent recording or latency issues typical in high-frequency systems. This irregularity reflects realistic market behavior, where asynchronous updates and data fragmentation occur due to system delays or sparse activity in illiquid moments.</p>
<p>Each record contains Level 1 and Level 2 order book features, including the best bid and ask prices and their associated volumes. These features form the foundation for constructing higher-order indicators which will be used as input for our models later.</p>
<p><b>Volatility-Stratified Subsets for Regime Evalutation</b></p>
<p>To systematically evaluate model performance under different market conditions, we curated three volatility-stratified datasets from the core pool of anonymised stock. Stratification was based on average realised volatility computed at the time bucket level (see Section <i>Feature Engineering</i> for details) across each stock, with subsequent ranking:</p>
<ul>
<li><p>High-Volatility Dataset <code>df_high</code>: Top 5 stocks by average volatility.</p></li>
<li><p>Low-Volatility Dataset <code>df_low</code>: Bottom 5 stocks</p></li>
<li><p>General Dataset <code>df_general</code>: Random selection of 5 stocks in neither extreme groups, used as a baseline for model development.</p></li>
</ul>
<p>Each subset contains 100 randomly sample <code>time_id</code>s per stock, concatenated into one final labeled dataset using a common preprocessing function <code>generate_representative_dataset</code>.</p>
<p><i>Note: For full reproducibility, ranking logic and stock selections are found in <code>stock_ranking.py</code> within main code repository</i></p>
<p><b> Additional Dataset of App Deployment</b> For real-world applicability, we also incorporated a complementary dataset supplemented by Optiver, featuring real stocks, including publicly traded firms such as Apple, Amazon, and many more. Unlike the anonymised dataset, this version includes identifiable stock tickers and real timestamps, with <code>time_id</code>s that are sequential and mappable to specific trading sessions. This dataset was integrated into our interactive application, enabling simulated predictions in a setting closer to live trading environments.</p>
<div id="677cbaca" class="cell" data-tags="[&quot;hide_input&quot;,&quot;hide_output&quot;]" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Standard libraries including for plotting</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.gridspec <span class="im">as</span> gridspec</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shap</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.exceptions <span class="im">import</span> ConvergenceWarning </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> TimeSeriesSplit  <span class="co"># Add this import</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># import all model libraries </span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> lightgbm <span class="im">as</span> lgb</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> xgboost <span class="im">as</span> xgb </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> HuberRegressor</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestRegressor</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> arch <span class="im">import</span> arch_model</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># import metrics</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error, mean_absolute_error</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Suppress warnings </span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, module<span class="op">=</span><span class="st">"arch"</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, category<span class="op">=</span>ConvergenceWarning)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="8e17b63e" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_representative_dataset(stock_files, label, sample_size<span class="op">=</span><span class="dv">100</span>, seed<span class="op">=</span><span class="dv">42</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Generate a merged dataset from a list of stock CSVs, sampling time_ids per stock.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">        stock_files (list): List of stock CSV filenames.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">        label (str): A label to tag the resulting dataset (e.g. 'high', 'low', 'general').</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">        sample_size (int): Number of unique time_ids to sample from each stock.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">        seed (int): Random seed for reproducibility.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">        pd.DataFrame: Merged sampled dataset with 'stock_name' and 'label' columns.</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    np.random.seed(seed)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    sampled_dfs <span class="op">=</span> []</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> stock_files:</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        stock_df <span class="op">=</span> pd.read_csv(<span class="bu">file</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        stock_name <span class="op">=</span> <span class="bu">file</span>.split(<span class="st">'.'</span>)[<span class="dv">0</span>]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        sampled_ids <span class="op">=</span> np.random.choice(stock_df[<span class="st">'time_id'</span>].unique(), size<span class="op">=</span>sample_size, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        sampled_df <span class="op">=</span> stock_df[stock_df[<span class="st">'time_id'</span>].isin(sampled_ids)].copy()</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        sampled_df[<span class="st">'stock_name'</span>] <span class="op">=</span> stock_name</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        sampled_df[<span class="st">'dataset_label'</span>] <span class="op">=</span> label</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        sampled_dfs.append(sampled_df)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.concat(sampled_dfs, ignore_index<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="8f6c89cb" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define stock groups</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>general_stocks <span class="op">=</span> [<span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_39.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_47.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_61.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_84.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_93.csv'</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>high_vol_stocks <span class="op">=</span> [<span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_6.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_27.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_75.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_80.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_18.csv'</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>low_vol_stocks <span class="op">=</span> [<span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_41.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_43.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_29.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_46.csv'</span>, <span class="st">'/Users/cuongtrantrong/Documents/study/usyd/Y3/DATA3888/Group/individual_book_train/stock_125.csv'</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Create datasets</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>df_general <span class="op">=</span> generate_representative_dataset(general_stocks, label<span class="op">=</span><span class="st">'general'</span>) </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>df_high <span class="op">=</span> generate_representative_dataset(high_vol_stocks, label<span class="op">=</span><span class="st">'high'</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>df_low <span class="op">=</span> generate_representative_dataset(low_vol_stocks, label<span class="op">=</span><span class="st">'low'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="data-preprocessing" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="data-preprocessing"><span class="header-section-number">4.2</span> 2.2 Data Preprocessing</h3>
<p>To derive informative features from the raw order book snapshots, we computed the Weighted Average Price (WAP) for each second using the formula: <span class="math display">\[
\text{WAP} = \frac{P_{bid}^{(1)}\cdot V_{bid}^{(1)} + P_{ask}^{(1)}\cdot V_{ask}^{(1)}}{V_{bid}^{(1)}+V_{ask}^{(1)}}
\]</span></p>
<p>where <span class="math inline">\(P\)</span> and <span class="math inline">\(V\)</span> denote price and volume at Level 1, respectively. This metric provides a smoothed, volume-sensitive estimate of trade execution price at each second, minimizing the noise from short-lived bid-ask fluctuations.</p>
<p>Our target variable—realized volatility—was constructed by aggregating log returns over a time ID. Log returns were calculated using the WAP, given by: <span class="math display">\[
r_t = \log{(\text{WAP}_t)} - \log{(\text{WAP}_{t-1})}
\]</span></p>
<p>Due to the non-sequential nature of time IDs, return-based calculations were constrained to within individual time IDs only. This design choice preserves the integrity of within-segment volatility dynamics and avoids false assumptions of temporal continuity.</p>
<p>Missing WAP values led to undefined returns; in such cases, we replaced NaN log returns with 0, effectively indicating no price movement. While simplistic, this imputation reflects the common assumption in high-frequency settings that missing ticks represent moments of inactivity. We acknowledge that this may understate micro-level volatility, but it ensures computational tractability and model compatibility.</p>
<p>To model volatility at a practically meaningful resolution, we segmented each time ID into 20-second intervals, chosen to align with real-time decision horizons in high-frequency trading. Realized volatility over each 20-second window was computed as the square root of the sum of squared log returns: <span class="math display">\[
RV_{[t,t+20]} = \sqrt{\sum_{i=t}^{t+19} r_i^2}
\]</span> This approach captures short-term market turbulence while smoothing out momentary spikes.</p>
<p>Due to the computational intensity of processing full-depth limit order books across all 126 stocks, we selected 5 stocks at random to represent a diverse, unknown subset of trading behaviors. This subsampling strategy mirrors the real-world scenario of forecasting volatility in unseen or newly listed instruments, enhancing the generalizability of our findings.</p>
<p>Finally, to ensure fair model training and evaluation, we verified that each of the selected stocks contained a sufficient number of unique time IDs, guaranteeing ample data for iteration and statistical robustness.</p>
<div id="c74ee187" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_wap(df):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (df[<span class="st">'bid_price1'</span>] <span class="op">*</span> df[<span class="st">'ask_size1'</span>] <span class="op">+</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'ask_price1'</span>] <span class="op">*</span> df[<span class="st">'bid_size1'</span>]) <span class="op">/</span> (df[<span class="st">'bid_size1'</span>] <span class="op">+</span> df[<span class="st">'ask_size1'</span>])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_log_returns(wap_series):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.log(wap_series).diff().fillna(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="feature-engineering" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="feature-engineering"><span class="header-section-number">4.3</span> 2.3 Feature Engineering</h3>
<p>To rigorously compare machine learning and traditional econometric models, we engineered a common set of high-frequency features that reflect real-time market dynamics. These features aim to capture the subtle, early signs of volatility—moments when prices become unstable, spreads widen, or liquidity disappears. Each feature class was chosen to reflect a different mechanism that can trigger short-term volatility.</p>
<ol type="1">
<li><b>Volatility Memory</b>: <code>log_ret_std</code></li>
</ol>
<p>We begin by capturing recent return variability using rolling standard deviations of log returns over 1 to 5 second windows. These features quantify how noisy or stable the price path has been in the immediate past. Since volatility often clusters in time, this “memory” of past turbulence gives models a foundation for short-term forecasting.</p>
<ol start="2" type="1">
<li><b>Momentum and Directionality</b>: <code>wap_lag</code>, <code>wap_delta</code>, <code>wap_trend_5s</code></li>
</ol>
<p>To capture price direction and shifts in momentum, we compute lagged values and changes in the Weighted Average Price (WAP), which integrates bid and ask data into a smoothed mid-price. We also construct a five-second WAP trend to detect consistent directional moves. These features provide early signals of emerging market shifts that often precede volatility spikes.</p>
<ol start="3" type="1">
<li><b>Microstructure Frictions</b>: <code>spread</code>, <code>spread_lag</code>, <code>spread_delta</code></li>
</ol>
<p>The bid-ask spread reflects the immediate cost of executing a trade and reacts sensitively to market conditions. We track its current value, lagged versions, and recent changes to detect moments of stress—when spreads widen or contract suddenly. These dynamics can reflect thinning liquidity or rising uncertainty, both precursors to increased volatility.</p>
<ol start="4" type="1">
<li><b>Latent liquidity and Order Book Pressure</b></li>
</ol>
<p>Several features aim to quantify hidden market stress. * <code>liquidity_shock</code> captures sudden variability in top bid depth, relative to longer-term norms.</p>
<ul>
<li><p><code>imbalance_velocity</code> tracks how quickly buyer-seller dominance is shifting.</p></li>
<li><p><code>vol_weighted_vol</code> links large order size with price movement severity.</p></li>
<li><p><code>noise_ratio</code> proxies information quality in price movements.</p></li>
<li><p><code>hidden_liquidity</code> compares second-level order depth to the visible top level—an indicator of market participants’ confidence.</p></li>
</ul>
<p>Together, these features offer a granular view of how liquidity and sentiment evolve moment-to-moment in the order book. They are particularly valuable for machine learning models, which excel at identifying non-linear interactions among these signals.</p>
<div id="c46a0292" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_return_features(df):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        df[<span class="ss">f'log_ret_std_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> df[<span class="st">'log_ret'</span>].shift(<span class="dv">1</span>).rolling(window<span class="op">=</span>i, min_periods<span class="op">=</span><span class="dv">1</span>).std()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_wap_features(df):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> lag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        df[<span class="ss">f'wap_lag_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> df[<span class="st">'WAP'</span>].shift(lag)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        df[<span class="ss">f'wap_delta_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> df[<span class="st">'WAP'</span>] <span class="op">-</span> df[<span class="ss">f'wap_lag_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'wap_trend_5s'</span>] <span class="op">=</span> df[[<span class="ss">f'wap_delta_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)]].mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_spread_features(df):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'spread'</span>] <span class="op">=</span> (df[<span class="st">'ask_price1'</span>] <span class="op">-</span> df[<span class="st">'bid_price1'</span>]) <span class="op">/</span> df[<span class="st">'ask_price1'</span>]</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> lag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        df[<span class="ss">f'spread_lag_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> df[<span class="st">'spread'</span>].shift(lag)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        df[<span class="ss">f'spread_delta_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> df[<span class="st">'spread'</span>] <span class="op">-</span> df[<span class="ss">f'spread_lag_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_liquidity_features(df):</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'liquidity_shock'</span>] <span class="op">=</span> df[<span class="st">'bid_size1'</span>].rolling(<span class="dv">5</span>).std() <span class="op">/</span> df[<span class="st">'bid_size1'</span>].rolling(<span class="dv">20</span>).mean()</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'imbalance_velocity'</span>] <span class="op">=</span> ((df[<span class="st">'bid_size1'</span>] <span class="op">-</span> df[<span class="st">'ask_size1'</span>]) <span class="op">/</span> (df[<span class="st">'bid_size1'</span>] <span class="op">+</span> df[<span class="st">'ask_size1'</span>])).diff().rolling(<span class="dv">3</span>).mean()</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'vol_weighted_vol'</span>] <span class="op">=</span> df[<span class="st">'log_ret'</span>].<span class="bu">abs</span>() <span class="op">*</span> df[<span class="st">'bid_size1'</span>].rolling(<span class="dv">10</span>).<span class="bu">sum</span>()</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'noise_ratio'</span>] <span class="op">=</span> df[<span class="st">'ask_price1'</span>].diff().<span class="bu">abs</span>() <span class="op">/</span> df[<span class="st">'WAP'</span>].diff().<span class="bu">abs</span>().rolling(<span class="dv">5</span>).std()</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'hidden_liquidity'</span>] <span class="op">=</span> (df[<span class="st">'bid_size2'</span>] <span class="op">+</span> df[<span class="st">'ask_size2'</span>]) <span class="op">/</span> (df[<span class="st">'bid_size1'</span>] <span class="op">+</span> df[<span class="st">'ask_size1'</span>])</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="model-candidates" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="model-candidates"><span class="header-section-number">5</span> Model Candidates</h2>
<p>In selecting our candidate models, we aimed to span a large spectrum of volatility forecasting paradigms—comparing advanced machine learning to a traditional benchmark, with simpler models chosen to provide context for incremental gains and diagnostic insight.</p>
<p>At the center of comparison is EGARCH, our traditional econometric benchmark. Its ability to model volatility clustering and asymmetry makes it a well-established standard—but one whose assumptions may not hold in high-frequency, order book–driven environments.</p>
<p>Challenging EGARCH are two leading gradient boosting methods: * <b>XGBoost</b> (Chen &amp; Guestrin, 2016): A high-performance ensemble model that excels at modeling nonlinear interactions through sequential tree boosting with regularisation.</p>
<ul>
<li><b>LightGBM</b> (Ke et al., 2017): A faster successor of XGBoost from Microsoft, optimised for speed and memory efficiency via histogram-based splitting and leaf-wise tree growth.</li>
</ul>
<p>These models are particularly well-suited to our engineered order book features, such as liquidity shocks and spread dynamics, which may interact in complex, nonlinear ways not easily captured by traditional models.</p>
<p>To contextualise the performance of gradient boosting, we include two interpretable alternatives: 1. <b>Random Forest</b> (Breiman, 2001): A robust but simpler ensemble method that helps distinguish whether gradient boosting’s sequential error correction outperforms mere feature randomisation.</p>
<ol start="2" type="1">
<li><b>Huber Regression</b> (Yunlong &amp; Qiang 2022): A linear model robust to outliers, merging the efficiencyt of ordinary least squares with resilience of median-based approaches. Its inclusion tests whether volatility patterns are funcamentally nonlinear or explicable through robust linear relationships.</li>
</ol>
<p>Rather than primary competitors, Random Forest and Huber Regressor serve as analytical baselines. Their role is diagnostic:</p>
<ul>
<li><p>If LightGBM and XGBoost outperform both EGARCH and Random Forest, we attribute the gains to their capacity to model nonlinear interactions and adapt to local structures in the data.</p></li>
<li><p>If Huber Regressor performs comparably to EGARCH, it suggests that volatility patterns may not require complex models to achieve useful forecasts.</p></li>
</ul>
<p><b>Why This Hierarchy?</b></p>
<p>By centering EGARCH as the benchmark and gradient boosting as its challengers—with Random Forest and Huber Regressor as reference points— we create a framework to unveil where performance gains come from.</p>
</section>
<section id="model-building" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="model-building"><span class="header-section-number">6</span> Model Building</h2>
<p>With our candidate models and shared feature set established, we turned to constructing a unified training pipeline. All models were passed through a shared data preprocessing pipeline.</p>
<p>All features were generated using the <code>engineer_features()</code> function, which systematically combined return-based, liquidity, and spread-related indicators. Infinite values (common in ratios and log-differences) were replaced with NaNs, which were then forward- and back-filled, with any residual gaps filled with zeros. This ensured robustness without introducing artificial volatility signals.</p>
<div id="3948fce9" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function that creates all features defined above at once </span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> engineer_features(df):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> add_return_features(df)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> add_wap_features(df)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> add_spread_features(df)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> add_liquidity_features(df)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.replace([np.inf, <span class="op">-</span>np.inf], np.nan)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df.ffill().bfill().fillna(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>To avoid data leakage, we carefully structured our splits within each <code>time_id</code>, ensuring that only past data informed future predictions. Each <code>time_id</code> was divided into training (<span class="math inline">\(64\%\)</span>), validation (<span class="math inline">\(16\%\)</span>), and test (<span class="math inline">\(20\%\)</span>) sets based on <code>seconds_in_bucket</code>. To prevent lookahead bias from lag-based features, the first 5 rows were systematically dropped. Each model thus operated on a lag-aware, leak-free, and uniformly engineered feature space.</p>
<div id="63b377a8" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function for splitting into train/val/test sets </span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_data(df, feature_cols, target_col<span class="op">=</span><span class="st">'log_ret'</span>):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df[df[<span class="st">'seconds_in_bucket'</span>] <span class="op">&gt;=</span> <span class="dv">5</span>].reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    train_val_mask <span class="op">=</span> df[<span class="st">'seconds_in_bucket'</span>] <span class="op">&lt;=</span> <span class="dv">480</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    test_mask <span class="op">=</span> df[<span class="st">'seconds_in_bucket'</span>] <span class="op">&gt;</span> <span class="dv">480</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    train_mask <span class="op">=</span> df[<span class="st">'seconds_in_bucket'</span>] <span class="op">&lt;=</span> <span class="dv">480</span> <span class="op">*</span> <span class="fl">0.8</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    val_mask <span class="op">=</span> (df[<span class="st">'seconds_in_bucket'</span>] <span class="op">&gt;</span> <span class="dv">480</span> <span class="op">*</span> <span class="fl">0.8</span>) <span class="op">&amp;</span> train_val_mask</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        df[train_mask][feature_cols], df[train_mask][target_col],</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        df[val_mask][feature_cols], df[val_mask][target_col],</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        df[test_mask][feature_cols], df[test_mask][target_col],</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        df[test_mask]</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Each model received theory-informed base parameters, where our focus was on reflecting the core constraints of high-frequency environments: short sample lengths, noise-dominated returns, and rapidly changing regimes.</p>
<p>All tree-based models were restricted to shallow depths (<code>max_depth: 5</code>) and moderate complexity (e.g., <code>num_leaves:31</code>, <code>min_data_in_leaf: 20</code>) to prevent overfitting nd to match the low signal-to-noise ratio typical of short time windows in finacial microstructure data. learning rates (0.03) were chosen conservatively to encourage generalisable learning across <code>time_id</code>s, while subsampling and column sampling introduced controlled randomness to reduce variance.</p>
<p>Models such as LightGBM and XGBoost included early stopping on a held-out validation set, ensuring that training ceased once additional rounds failed to improve performance—critical for guarding against overfitting on noisy targets. The Huber Regressor, known for robustness to outliers, used standard regularisation settings suitable for volatility data where occasional spikes may otherwise distort linear estimators.</p>
<div id="aa85a3a3" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Consistent parameters to feed in each model, based on theory </span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>BASE_PARAMS <span class="op">=</span> {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"lightgbm"</span>: {</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"learning_rate"</span>: <span class="fl">0.03</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"num_leaves"</span>: <span class="dv">31</span>,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"max_depth"</span>: <span class="dv">5</span>,</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_data_in_leaf"</span>: <span class="dv">20</span>,</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">"feature_fraction"</span>: <span class="fl">0.8</span>,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">"bagging_freq"</span>: <span class="dv">10</span>,</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">"verbosity"</span>: <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">"lambda_l2"</span>: <span class="dv">0</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    },</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"xgboost"</span>: {</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'objective'</span>: <span class="st">'reg:squarederror'</span>,</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">'eval_metric'</span>: <span class="st">'mae'</span>,</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">"learning_rate"</span>: <span class="fl">0.03</span>,</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">"max_depth"</span>: <span class="dv">5</span>,</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_child_weight"</span>: <span class="dv">5</span>,</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="st">"subsample"</span>: <span class="fl">0.8</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    },</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="st">"random_forest"</span>: {</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="st">"max_depth"</span>: <span class="dv">5</span>,</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_samples_leaf"</span>: <span class="dv">20</span>,</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        <span class="st">"n_estimators"</span>: <span class="dv">300</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    },</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="st">"huber"</span>: {</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        <span class="st">"epsilon"</span>: <span class="fl">1.35</span>, </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        <span class="st">"max_iter"</span>: <span class="dv">500</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The following code defines our training and prediction pipeline that handles all four model types under a consistent interface. For each test set, models predicted log returns for the final <span class="math inline">\(120\)</span> seconds of each <code>time_id</code>, which were grouped into six <span class="math inline">\(20\)</span> second buckets, and the realised volatility was computed. Results were aggregated across all <code>time_id</code> instances to form a final datafram of model-wise volatility predictions.</p>
<div id="284d85e8" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_and_predict(X_train, y_train, X_val, y_val, X_test, model_type<span class="op">=</span><span class="st">'lightgbm'</span>, model_params<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> model_params <span class="kw">or</span> {}</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> model_type <span class="op">==</span> <span class="st">'lightgbm'</span>:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        train_set <span class="op">=</span> lgb.Dataset(X_train, label<span class="op">=</span>y_train)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        val_set <span class="op">=</span> lgb.Dataset(X_val, label<span class="op">=</span>y_val)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> lgb.train(params, train_set, num_boost_round<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                          valid_sets<span class="op">=</span>[val_set], </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                          callbacks<span class="op">=</span>[lgb.early_stopping(<span class="dv">20</span>, verbose<span class="op">=</span><span class="dv">0</span>), lgb.log_evaluation(<span class="dv">0</span>)])</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        y_pred <span class="op">=</span> model.predict(X_test)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> model_type <span class="op">==</span> <span class="st">'xgboost'</span>:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        dtrain <span class="op">=</span> xgb.DMatrix(X_train, label<span class="op">=</span>y_train)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        dval <span class="op">=</span> xgb.DMatrix(X_val, label<span class="op">=</span>y_val)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> xgb.train(params, dtrain, num_boost_round<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>                          evals<span class="op">=</span>[(dval, <span class="st">"validation"</span>)], early_stopping_rounds<span class="op">=</span><span class="dv">20</span>, verbose_eval<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        y_pred <span class="op">=</span> model.predict(xgb.DMatrix(X_test))</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> model_type <span class="op">==</span> <span class="st">'random_forest'</span>:</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> RandomForestRegressor(<span class="op">**</span>params)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        model.fit(X_train, y_train)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        y_pred <span class="op">=</span> model.predict(X_test)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> model_type <span class="op">==</span> <span class="st">'huber'</span>:</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> HuberRegressor(<span class="op">**</span>params)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        model.fit(X_train, y_train)</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        y_pred <span class="op">=</span> model.predict(X_test)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Unsupported model type."</span>)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model, y_pred</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="c61ddef2" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_mda(actual, predicted):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    actual <span class="op">=</span> np.array(actual)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    predicted <span class="op">=</span> np.array(predicted)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    actual_diff <span class="op">=</span> np.diff(actual)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    actual_signs <span class="op">=</span> np.sign(actual_diff)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    predicted_diff <span class="op">=</span> np.diff(predicted)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    predicted_signs <span class="op">=</span> np.sign(predicted_diff)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    num_correct <span class="op">=</span> np.<span class="bu">sum</span>(actual_signs <span class="op">==</span> predicted_signs)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    mda <span class="op">=</span> num_correct <span class="op">/</span> (<span class="bu">len</span>(actual) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mda</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="730d4548" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_model_pipeline(data, model_type<span class="op">=</span><span class="st">'lightgbm'</span>):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create lists to store </span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    all_rv_dfs <span class="op">=</span> []</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    model_metrics <span class="op">=</span> []</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (stock, time_id), df_subset <span class="kw">in</span> data.groupby([<span class="st">'stock_name'</span>, <span class="st">'time_id'</span>]):</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> df_subset.copy()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'WAP'</span>] <span class="op">=</span> compute_wap(df)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'log_ret'</span>] <span class="op">=</span> compute_log_returns(df[<span class="st">'WAP'</span>])</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> engineer_features(df)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        feature_cols <span class="op">=</span> [<span class="ss">f'log_ret_std_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'wap_lag_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'wap_delta_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        [<span class="st">'wap_trend_5s'</span>] <span class="op">+</span> [<span class="st">'spread'</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'spread_lag_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'spread_delta_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        [<span class="st">'liquidity_shock'</span>, <span class="st">'imbalance_velocity'</span>, <span class="st">'vol_weighted_vol'</span>, <span class="st">'noise_ratio'</span>, <span class="st">'hidden_liquidity'</span>]</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Split</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            X_train, y_train, X_val, y_val, X_test, y_test, test_df <span class="op">=</span> split_data(df, feature_cols)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(X_train) <span class="op">&lt;</span> <span class="dv">10</span> <span class="kw">or</span> <span class="bu">len</span>(X_test) <span class="op">&lt;</span> <span class="dv">10</span>:</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Start training + prediction timer</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>            start_time <span class="op">=</span> time.time()</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Train</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>            model, y_pred <span class="op">=</span> train_and_predict(X_train, y_train, X_val, y_val, X_test, </span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>                                              model_type<span class="op">=</span>model_type,</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>                                              model_params<span class="op">=</span>BASE_PARAMS[model_type])</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>            end_time <span class="op">=</span> time.time()</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>            prediction_time <span class="op">=</span> end_time <span class="op">-</span> start_time <span class="co"># seconds </span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>            results_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>                <span class="st">'time_id'</span>: time_id,</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>                <span class="st">'seconds_in_bucket'</span>: test_df[<span class="st">'seconds_in_bucket'</span>].values,</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>                <span class="st">'y_true'</span>: y_test,</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>                <span class="st">'y_pred'</span>: y_pred</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>            })</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>            full_range <span class="op">=</span> pd.DataFrame({<span class="st">'seconds_in_bucket'</span>: np.arange(<span class="dv">480</span>, <span class="dv">600</span>)})</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>            results_df_filled <span class="op">=</span> pd.merge(full_range, results_df, on<span class="op">=</span><span class="st">'seconds_in_bucket'</span>, how<span class="op">=</span><span class="st">'left'</span>).fillna(<span class="dv">0</span>)</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>            results_df_filled[<span class="st">'time_bucket'</span>] <span class="op">=</span> (results_df_filled[<span class="st">'seconds_in_bucket'</span>] <span class="op">-</span> <span class="dv">480</span>) <span class="op">//</span> <span class="dv">20</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>            actual_rv <span class="op">=</span> results_df_filled.groupby(<span class="st">'time_bucket'</span>)[<span class="st">'y_true'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: np.sqrt(np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>            pred_rv <span class="op">=</span> results_df_filled.groupby(<span class="st">'time_bucket'</span>)[<span class="st">'y_pred'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: np.sqrt(np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>            rv_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>                <span class="st">'time_id'</span>: time_id,</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>                <span class="st">'time_bucket'</span>: actual_rv.index,</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>                <span class="st">'rv_actual'</span>: actual_rv.values,</span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>                <span class="st">'rv_predicted'</span>: pred_rv.values</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>            })</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>            all_rv_dfs.append(rv_df)</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>            rmse <span class="op">=</span> np.sqrt(mean_squared_error(actual_rv, pred_rv))</span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>            mae <span class="op">=</span> mean_absolute_error(actual_rv, pred_rv)</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>            mda <span class="op">=</span> calculate_mda(actual_rv.values, pred_rv.values)</span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>            model_metrics.append({</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>                <span class="st">'time_id'</span>: time_id,</span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>                <span class="st">'rmse'</span>: rmse,</span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>                <span class="st">'mae'</span>: mae,</span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>                <span class="st">'mda'</span>: mda,</span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>                <span class="st">'prediction_time'</span>: prediction_time</span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>            })</span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Error in time_id </span><span class="sc">{</span>time_id<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.concat(all_rv_dfs), pd.DataFrame(model_metrics)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="382a804f" class="cell" data-scrolled="true" data-tags="[&quot;hide_output&quot;]" data-results="hide" data-message="false" data-execution_count="24">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>all_metrics <span class="op">=</span> []</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>all_rv_preds <span class="op">=</span> []</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> model_name <span class="kw">in</span> [<span class="st">'lightgbm'</span>, <span class="st">'xgboost'</span>, <span class="st">'random_forest'</span>, <span class="st">'huber'</span>]:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Running </span><span class="sc">{</span>model_name<span class="sc">}</span><span class="ss"> model..."</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    rv_df, metrics_df <span class="op">=</span> run_model_pipeline(</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        data<span class="op">=</span>df_general, </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        model_type<span class="op">=</span>model_name</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    rv_df[<span class="st">'model'</span>] <span class="op">=</span> model_name</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    metrics_df[<span class="st">'model'</span>] <span class="op">=</span> model_name</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    all_rv_preds.append(rv_df)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    all_metrics.append(metrics_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Running lightgbm model...
Running xgboost model...
Running random_forest model...
Running huber model...
Error in time_id 14435: HuberRegressor convergence failed: l-BFGS-b solver terminated with ABNORMAL: </code></pre>
</div>
</div>
<section id="egarch-model" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="egarch-model"><span class="header-section-number">6.1</span> EGARCH model</h3>
<div id="42fa95a0" class="cell" data-tags="[&quot;hide_output&quot;]" data-results="hide" data-message="false" data-execution_count="25">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>all_rv_dfs <span class="op">=</span> []</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>model_metrics <span class="op">=</span> []</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (stock, time_id), df_subset <span class="kw">in</span> df_general.groupby([<span class="st">'stock_name'</span>, <span class="st">'time_id'</span>]):</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df_subset.copy()</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate WAP</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'WAP'</span>] <span class="op">=</span> compute_wap(df)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate Log Returns from WAP </span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_ret'</span>] <span class="op">=</span> compute_log_returns(df[<span class="st">'WAP'</span>])</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    train_mask <span class="op">=</span> (df[<span class="st">'seconds_in_bucket'</span>] <span class="op">&lt;=</span> <span class="dv">480</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    test_mask <span class="op">=</span> (df[<span class="st">'seconds_in_bucket'</span>] <span class="op">&gt;</span> <span class="dv">480</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    y_train <span class="op">=</span> df[train_mask][<span class="st">'log_ret'</span>].values</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    y_test <span class="op">=</span> df[test_mask][<span class="st">'log_ret'</span>].values</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scaled log returns to prevent values from failing to be read due to small magnitude</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    scaling_factor <span class="op">=</span> <span class="fl">1e4</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    y_train_scaled <span class="op">=</span> y_train <span class="op">*</span> <span class="fl">1e4</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> arch_model(</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>            y_train_scaled,</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>            mean<span class="op">=</span><span class="st">'Constant'</span>,  <span class="co"># Simple constant mean</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>            vol<span class="op">=</span><span class="st">'EGARCH'</span>,</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>            p<span class="op">=</span><span class="dv">1</span>,  <span class="co"># ARCH term order</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>            o<span class="op">=</span><span class="dv">1</span>,  <span class="co"># Asymmetry term order</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>            q<span class="op">=</span><span class="dv">1</span>,  <span class="co"># GARCH term order</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>            dist<span class="op">=</span><span class="st">'normal'</span>  </span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Start training + prediction timer</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> model.fit(update_freq<span class="op">=</span><span class="dv">0</span>, disp<span class="op">=</span><span class="st">'off'</span>, options<span class="op">=</span>{<span class="st">'maxiter'</span>: <span class="dv">500</span>})</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> res.convergence_flag <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Model failed to converge for time_id </span><span class="sc">{</span>time_id<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Forecast volatility</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>    forecasts <span class="op">=</span> res.forecast(</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>        horizon<span class="op">=</span><span class="bu">len</span>(y_test),</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>        method<span class="op">=</span><span class="st">'simulation'</span>,</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>        reindex<span class="op">=</span><span class="va">False</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>    mean_forecast <span class="op">=</span> forecasts.mean.values[<span class="op">-</span><span class="dv">1</span>, :]</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>    end_time <span class="op">=</span> time.time()</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>    prediction_time <span class="op">=</span> end_time <span class="op">-</span> start_time <span class="co"># seconds </span></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>    results_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>        <span class="st">'time_id'</span>: time_id,</span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>        <span class="st">'seconds_in_bucket'</span>: df[test_mask][<span class="st">'seconds_in_bucket'</span>].values,</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>        <span class="st">'y_true'</span>: y_test,</span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>        <span class="st">'y_pred'</span>: mean_forecast</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>    full_range <span class="op">=</span> pd.DataFrame({<span class="st">'seconds_in_bucket'</span>: np.arange(<span class="dv">480</span>, <span class="dv">600</span>)})</span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>    results_df_filled <span class="op">=</span> pd.merge(full_range, results_df, on<span class="op">=</span><span class="st">'seconds_in_bucket'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a>    results_df_filled[<span class="st">'y_pred'</span>] <span class="op">=</span> results_df_filled[<span class="st">'y_pred'</span>].fillna(<span class="dv">0</span>)</span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a>    results_df_filled[<span class="st">'y_true'</span>] <span class="op">=</span> results_df_filled[<span class="st">'y_true'</span>].fillna(<span class="dv">0</span>)</span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a>    results_df_filled[<span class="st">'time_bucket'</span>] <span class="op">=</span> (results_df_filled[<span class="st">'seconds_in_bucket'</span>] <span class="op">-</span> <span class="dv">480</span>) <span class="op">//</span> <span class="dv">20</span></span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a>    actual_rv <span class="op">=</span> results_df_filled.groupby(<span class="st">'time_bucket'</span>)[<span class="st">'y_true'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: np.sqrt(np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a>    pred_rv <span class="op">=</span> results_df_filled.groupby(<span class="st">'time_bucket'</span>)[<span class="st">'y_pred'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: np.sqrt(np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>))) <span class="op">/</span> <span class="fl">1e4</span></span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a>    rv_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a>        <span class="st">'time_id'</span>: time_id,</span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a>        <span class="st">'time_bucket'</span>: actual_rv.index,</span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true" tabindex="-1"></a>        <span class="st">'rv_actual'</span>: actual_rv.values,</span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true" tabindex="-1"></a>        <span class="st">'rv_predicted'</span>: pred_rv.values,</span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true" tabindex="-1"></a>        <span class="st">'model'</span>: <span class="st">'egarch'</span></span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true" tabindex="-1"></a>    all_rv_dfs.append(rv_df)</span>
<span id="cb14-76"><a href="#cb14-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-77"><a href="#cb14-77" aria-hidden="true" tabindex="-1"></a>    rmse <span class="op">=</span> np.sqrt(mean_squared_error(actual_rv, pred_rv))</span>
<span id="cb14-78"><a href="#cb14-78" aria-hidden="true" tabindex="-1"></a>    mae <span class="op">=</span> mean_absolute_error(actual_rv, pred_rv)</span>
<span id="cb14-79"><a href="#cb14-79" aria-hidden="true" tabindex="-1"></a>    mda <span class="op">=</span> calculate_mda(actual_rv.values, pred_rv.values)</span>
<span id="cb14-80"><a href="#cb14-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-81"><a href="#cb14-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store metrics</span></span>
<span id="cb14-82"><a href="#cb14-82" aria-hidden="true" tabindex="-1"></a>    model_metrics.append({</span>
<span id="cb14-83"><a href="#cb14-83" aria-hidden="true" tabindex="-1"></a>        <span class="st">'time_id'</span>: time_id,</span>
<span id="cb14-84"><a href="#cb14-84" aria-hidden="true" tabindex="-1"></a>        <span class="st">'rmse'</span>: rmse,</span>
<span id="cb14-85"><a href="#cb14-85" aria-hidden="true" tabindex="-1"></a>        <span class="st">'mae'</span>: mae,</span>
<span id="cb14-86"><a href="#cb14-86" aria-hidden="true" tabindex="-1"></a>        <span class="st">'mda'</span>: mda,</span>
<span id="cb14-87"><a href="#cb14-87" aria-hidden="true" tabindex="-1"></a>        <span class="st">'prediction_time'</span>: prediction_time,</span>
<span id="cb14-88"><a href="#cb14-88" aria-hidden="true" tabindex="-1"></a>        <span class="st">'model'</span>: <span class="st">'egarch'</span></span>
<span id="cb14-89"><a href="#cb14-89" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb14-90"><a href="#cb14-90" aria-hidden="true" tabindex="-1"></a><span class="co"># Finalize EGARCH DataFrames</span></span>
<span id="cb14-91"><a href="#cb14-91" aria-hidden="true" tabindex="-1"></a>egarch_rv_df <span class="op">=</span> pd.concat(all_rv_dfs, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-92"><a href="#cb14-92" aria-hidden="true" tabindex="-1"></a>egarch_metrics_df <span class="op">=</span> pd.DataFrame(model_metrics)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 1513</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 13305</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 20935
Model failed to converge for time_id 25680</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 28838</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 2076
Model failed to converge for time_id 4265</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 5193
Model failed to converge for time_id 6020
Model failed to converge for time_id 6235</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 7674
Model failed to converge for time_id 10070
Model failed to converge for time_id 10610</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 13598</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 13928</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 20317</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 21897</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 24989</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 30212</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 2076</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 5904</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 10892</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 30657
Model failed to converge for time_id 627</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 4219</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 8534</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 21307</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 2184
Model failed to converge for time_id 4310</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 12419</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 13484</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model failed to converge for time_id 27771</code></pre>
</div>
</div>
</section>
</section>
<section id="evaluation-metrics" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="evaluation-metrics"><span class="header-section-number">7</span> Evaluation Metrics</h2>
<p>To comprehensively assess model performance, we employed three core evaluation metrics: Root Mean Square Error (RMSE), Mean Absolute Error (MAE), and Mean Directional Accuracy (MDA). RMSE and MAE capture the magnitude of prediction errors, while MDA evaluates directional correctness—a critical dimension in volatility forecasting.</p>
<p>RMSE penalizes large deviations more heavily, making it particularly suited to risk-sensitive applications where large forecasting errors could disrupt trading decisions. In contrast, MAE provides a more balanced view by averaging absolute differences, offering robustness against outliers and noisy fluctuations common in high-frequency data. MDA complements these by measuring how often the model correctly predicts the direction of volatility movements—information that is vital for traders looking to anticipate regime shifts and manage positions proactively.</p>
</section>
<section id="results" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="results"><span class="header-section-number">8</span> Results</h2>
<p>Our empirical analysis reveals dramatic performance differences across model architectures when predicting high-frequency volatility. Figure 2 presents comprehensive results averaged across all <code>time_id</code>s from the primary evaluation dataset.</p>
<p>LightGBM achieved the lowest RMSE of <span class="math inline">\(0.000091\)</span>, representing a <span class="math inline">\(99.76\%\)</span> improvement over the traditional EGARCH baseline and a remarkable <span class="math inline">\(70\%\)</span> improvement over XGBoost. More critically, LightGBM’s directional accuracy of <span class="math inline">\(87.12\%\)</span> far exceeded random chance, correctly predicting volatility regime changes in nearly 9 out of 10 cases.</p>
<p><b>The XGBoost Paradox</b></p>
<p>Perhaps the most striking finding was XGBoost’s unexpected underperformance, falling behind even simpler baselines like Huber regression. Despite sharing gradient boosting fundamentals with LightGBM, XGBoost achieved an RMSE three times higher and significantly lower directional accuracy. This counterintuitive result highlights that boosting algorithms are not interchangeable in high-frequency financial applications.</p>
<p>XGBoost’s poor performance likely stems from subtle incompatibilities with our data regime: 120-second input sequences, high-frequency noise, and sharp volatility spikes. Unlike LightGBM’s optimized histogram binning and leaf-wise growth, XGBoost’s level-wise tree construction and default regularization may have led to over-pruning of critical micro-patterns essential for volatility prediction. This finding emphasizes that algorithm selection must align precisely with data characteristics in time-sensitive financial modeling.</p>
<p><b>Speed and Deployment Feasibility</b> Real-time deployment requirements strongly favor LightGBM despite slightly higher latency than Huber regression. At 0.157 milliseconds per prediction, LightGBM remains well within the sub-millisecond thresholds demanded by high-frequency trading systems. Random Forest’s 0.904-second prediction time renders it impractical for live trading, while EGARCH’s traditional econometric estimation proves both slow and inaccurate.</p>
<p>The speed-accuracy trade-off clearly favors LightGBM: its 87% directional accuracy combined with sub-millisecond predictions creates substantial competitive advantages for algorithmic trading strategies requiring rapid risk adjustment.</p>
<div id="2a0aa060" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Append egarch to other modeks</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>all_rv_preds.append(egarch_rv_df)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>all_metrics.append(egarch_metrics_df)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>final_rv_results <span class="op">=</span> pd.concat(all_rv_preds, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>final_metrics <span class="op">=</span> pd.concat(all_metrics, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Average RMSE, MAE, MDA per model </span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>avg_metrics_df <span class="op">=</span> final_metrics.groupby(<span class="st">"model"</span>)[[<span class="st">"rmse"</span>, <span class="st">"mae"</span>, <span class="st">"mda"</span>, <span class="st">"prediction_time"</span>]].mean().reset_index()</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the metrics for better visual comparison</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'seaborn-v0_8-whitegrid'</span>)</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>custom_palette <span class="op">=</span> {</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"rmse"</span>: <span class="st">"#f3e9d2"</span>,   <span class="co"># Beige</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"mae"</span>:  <span class="st">"#01426a"</span>,  <span class="co"># Navy</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"mda"</span>: <span class="st">"#76c7c0"</span>    <span class="co"># Teal</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Prepare data</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>plot_df <span class="op">=</span> avg_metrics_df.melt(id_vars<span class="op">=</span><span class="st">"model"</span>, var_name<span class="op">=</span><span class="st">"metric"</span>, value_name<span class="op">=</span><span class="st">"score"</span>)</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>model_order <span class="op">=</span> [<span class="st">"egarch"</span>, <span class="st">"huber"</span>, <span class="st">"lightgbm"</span>, <span class="st">"random_forest"</span>, <span class="st">"xgboost"</span>]</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Split by metric</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>rmse_mae_df <span class="op">=</span> plot_df[plot_df[<span class="st">"metric"</span>].isin([<span class="st">"rmse"</span>, <span class="st">"mae"</span>])]</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>mda_df <span class="op">=</span> plot_df[plot_df[<span class="st">"metric"</span>] <span class="op">==</span> <span class="st">"mda"</span>]</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Create subplots with custom width ratio (65:35)</span></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">6</span>), dpi<span class="op">=</span><span class="dv">120</span>)</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>gs <span class="op">=</span> gridspec.GridSpec(<span class="dv">1</span>, <span class="dv">2</span>, width_ratios<span class="op">=</span>[<span class="fl">1.3</span>, <span class="fl">0.7</span>], wspace<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a><span class="co"># --- LEFT: RMSE &amp; MAE Grouped Bar Plot ---</span></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> fig.add_subplot(gs[<span class="dv">0</span>])</span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>sns.barplot(</span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>rmse_mae_df,</span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"model"</span>,</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">"score"</span>,</span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>    hue<span class="op">=</span><span class="st">"metric"</span>,</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>    order<span class="op">=</span>model_order,</span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>    hue_order<span class="op">=</span>[<span class="st">"rmse"</span>, <span class="st">"mae"</span>],</span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>    palette<span class="op">=</span>custom_palette,</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>ax1,</span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>    saturation<span class="op">=</span><span class="fl">0.85</span>,</span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>    errwidth<span class="op">=</span><span class="fl">1.5</span>,</span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>    capsize<span class="op">=</span><span class="fl">0.05</span></span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Title + axis</span></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"Model Performance Comparison</span><span class="ch">\n</span><span class="st">Lower RMSE/MAE is Better"</span>, fontsize<span class="op">=</span><span class="dv">14</span>, pad<span class="op">=</span><span class="dv">20</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">"Model"</span>, labelpad<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">"Score (log scale)"</span>, labelpad<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a>ax1.set_xticklabels(ax1.get_xticklabels(), rotation<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>ax1.set_yscale(<span class="st">"log"</span>)</span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Value labels (scientific notation)</span></span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> ax1.patches:</span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>    height <span class="op">=</span> p.get_height()</span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a>    ax1.text(</span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span>p.get_x() <span class="op">+</span> p.get_width() <span class="op">/</span> <span class="dv">2</span>,</span>
<span id="cb39-59"><a href="#cb39-59" aria-hidden="true" tabindex="-1"></a>        y<span class="op">=</span>height <span class="op">*</span> <span class="fl">1.05</span>,</span>
<span id="cb39-60"><a href="#cb39-60" aria-hidden="true" tabindex="-1"></a>        s<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>height<span class="sc">:.2e}</span><span class="ss">"</span>,</span>
<span id="cb39-61"><a href="#cb39-61" aria-hidden="true" tabindex="-1"></a>        ha<span class="op">=</span><span class="st">"center"</span>,</span>
<span id="cb39-62"><a href="#cb39-62" aria-hidden="true" tabindex="-1"></a>        va<span class="op">=</span><span class="st">"bottom"</span>,</span>
<span id="cb39-63"><a href="#cb39-63" aria-hidden="true" tabindex="-1"></a>        fontsize<span class="op">=</span><span class="dv">9</span></span>
<span id="cb39-64"><a href="#cb39-64" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb39-65"><a href="#cb39-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-66"><a href="#cb39-66" aria-hidden="true" tabindex="-1"></a><span class="co"># Highlight best (lowest) RMSE and MAE</span></span>
<span id="cb39-67"><a href="#cb39-67" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> highlight_best(ax, color<span class="op">=</span><span class="st">"#b50505"</span>, label<span class="op">=</span><span class="st">"Best"</span>):</span>
<span id="cb39-68"><a href="#cb39-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sum RMSE + MAE per model</span></span>
<span id="cb39-69"><a href="#cb39-69" aria-hidden="true" tabindex="-1"></a>    combined_scores <span class="op">=</span> rmse_mae_df.groupby(<span class="st">"model"</span>)[<span class="st">"score"</span>].<span class="bu">sum</span>()</span>
<span id="cb39-70"><a href="#cb39-70" aria-hidden="true" tabindex="-1"></a>    best_model <span class="op">=</span> combined_scores.idxmin()</span>
<span id="cb39-71"><a href="#cb39-71" aria-hidden="true" tabindex="-1"></a>    best_val <span class="op">=</span> combined_scores.<span class="bu">min</span>()</span>
<span id="cb39-72"><a href="#cb39-72" aria-hidden="true" tabindex="-1"></a>    x_pos <span class="op">=</span> model_order.index(best_model)</span>
<span id="cb39-73"><a href="#cb39-73" aria-hidden="true" tabindex="-1"></a>    bar_width <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="cb39-74"><a href="#cb39-74" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-75"><a href="#cb39-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Soft Glow Rectangle ---</span></span>
<span id="cb39-76"><a href="#cb39-76" aria-hidden="true" tabindex="-1"></a>    ax.add_patch(</span>
<span id="cb39-77"><a href="#cb39-77" aria-hidden="true" tabindex="-1"></a>        plt.Rectangle(</span>
<span id="cb39-78"><a href="#cb39-78" aria-hidden="true" tabindex="-1"></a>            (x_pos <span class="op">-</span> bar_width, <span class="dv">0</span>),     <span class="co"># bottom-left corner</span></span>
<span id="cb39-79"><a href="#cb39-79" aria-hidden="true" tabindex="-1"></a>            bar_width <span class="op">*</span> <span class="dv">2</span>,                   <span class="co"># width</span></span>
<span id="cb39-80"><a href="#cb39-80" aria-hidden="true" tabindex="-1"></a>            ax.get_ylim()[<span class="dv">1</span>],                <span class="co"># height: full y-axis</span></span>
<span id="cb39-81"><a href="#cb39-81" aria-hidden="true" tabindex="-1"></a>            color<span class="op">=</span>color,</span>
<span id="cb39-82"><a href="#cb39-82" aria-hidden="true" tabindex="-1"></a>            alpha<span class="op">=</span><span class="fl">0.06</span>,                      <span class="co"># VERY soft glow</span></span>
<span id="cb39-83"><a href="#cb39-83" aria-hidden="true" tabindex="-1"></a>            zorder<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb39-84"><a href="#cb39-84" aria-hidden="true" tabindex="-1"></a>            linewidth<span class="op">=</span><span class="dv">0</span></span>
<span id="cb39-85"><a href="#cb39-85" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb39-86"><a href="#cb39-86" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb39-87"><a href="#cb39-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-88"><a href="#cb39-88" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Glowing Marker ---</span></span>
<span id="cb39-89"><a href="#cb39-89" aria-hidden="true" tabindex="-1"></a>    avg_y <span class="op">=</span> rmse_mae_df[rmse_mae_df[<span class="st">"model"</span>] <span class="op">==</span> best_model][<span class="st">"score"</span>].mean()</span>
<span id="cb39-90"><a href="#cb39-90" aria-hidden="true" tabindex="-1"></a>    ax.scatter(x<span class="op">=</span>x_pos, y<span class="op">=</span>avg_y <span class="op">*</span> <span class="dv">2</span>, s<span class="op">=</span><span class="dv">220</span>, color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.3</span>, zorder<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb39-91"><a href="#cb39-91" aria-hidden="true" tabindex="-1"></a>    ax.scatter(x<span class="op">=</span>x_pos, y<span class="op">=</span>avg_y <span class="op">*</span> <span class="dv">2</span>, s<span class="op">=</span><span class="dv">80</span>, color<span class="op">=</span>color, zorder<span class="op">=</span><span class="dv">6</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-92"><a href="#cb39-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-93"><a href="#cb39-93" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Floating Label ---</span></span>
<span id="cb39-94"><a href="#cb39-94" aria-hidden="true" tabindex="-1"></a>    ax.text(x_pos, avg_y <span class="op">*</span> <span class="fl">2.8</span>, <span class="ss">f"</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss">"</span>, fontsize<span class="op">=</span><span class="dv">10</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb39-95"><a href="#cb39-95" aria-hidden="true" tabindex="-1"></a>            ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>, color<span class="op">=</span>color, backgroundcolor<span class="op">=</span><span class="st">"white"</span>,</span>
<span id="cb39-96"><a href="#cb39-96" aria-hidden="true" tabindex="-1"></a>            bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">'round,pad=0.2'</span>, fc<span class="op">=</span><span class="st">'white'</span>, ec<span class="op">=</span>color, lw<span class="op">=</span><span class="fl">1.5</span>))</span>
<span id="cb39-97"><a href="#cb39-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-98"><a href="#cb39-98" aria-hidden="true" tabindex="-1"></a>highlight_best(ax1, color<span class="op">=</span><span class="st">"#b50505"</span>, label<span class="op">=</span><span class="st">"Best Overall"</span>)</span>
<span id="cb39-99"><a href="#cb39-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-100"><a href="#cb39-100" aria-hidden="true" tabindex="-1"></a><span class="co"># Legend</span></span>
<span id="cb39-101"><a href="#cb39-101" aria-hidden="true" tabindex="-1"></a>handles, labels <span class="op">=</span> ax1.get_legend_handles_labels()</span>
<span id="cb39-102"><a href="#cb39-102" aria-hidden="true" tabindex="-1"></a>ax1.legend(</span>
<span id="cb39-103"><a href="#cb39-103" aria-hidden="true" tabindex="-1"></a>    handles,</span>
<span id="cb39-104"><a href="#cb39-104" aria-hidden="true" tabindex="-1"></a>    [<span class="st">"RMSE"</span>, <span class="st">"MAE"</span>],</span>
<span id="cb39-105"><a href="#cb39-105" aria-hidden="true" tabindex="-1"></a>    frameon<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb39-106"><a href="#cb39-106" aria-hidden="true" tabindex="-1"></a>    loc<span class="op">=</span><span class="st">"upper right"</span>,</span>
<span id="cb39-107"><a href="#cb39-107" aria-hidden="true" tabindex="-1"></a>    bbox_to_anchor<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb39-108"><a href="#cb39-108" aria-hidden="true" tabindex="-1"></a>    borderpad<span class="op">=</span><span class="dv">1</span></span>
<span id="cb39-109"><a href="#cb39-109" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb39-110"><a href="#cb39-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-111"><a href="#cb39-111" aria-hidden="true" tabindex="-1"></a>sns.despine(ax<span class="op">=</span>ax1)</span>
<span id="cb39-112"><a href="#cb39-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-113"><a href="#cb39-113" aria-hidden="true" tabindex="-1"></a><span class="co"># --- RIGHT: MDA Bar Plot ---</span></span>
<span id="cb39-114"><a href="#cb39-114" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.add_subplot(gs[<span class="dv">1</span>])</span>
<span id="cb39-115"><a href="#cb39-115" aria-hidden="true" tabindex="-1"></a>sns.barplot(</span>
<span id="cb39-116"><a href="#cb39-116" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>mda_df,</span>
<span id="cb39-117"><a href="#cb39-117" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">"model"</span>,</span>
<span id="cb39-118"><a href="#cb39-118" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">"score"</span>,</span>
<span id="cb39-119"><a href="#cb39-119" aria-hidden="true" tabindex="-1"></a>    order<span class="op">=</span>model_order,</span>
<span id="cb39-120"><a href="#cb39-120" aria-hidden="true" tabindex="-1"></a>    ax<span class="op">=</span>ax2,</span>
<span id="cb39-121"><a href="#cb39-121" aria-hidden="true" tabindex="-1"></a>    saturation<span class="op">=</span><span class="fl">0.85</span>,</span>
<span id="cb39-122"><a href="#cb39-122" aria-hidden="true" tabindex="-1"></a>    errwidth<span class="op">=</span><span class="fl">1.5</span>,</span>
<span id="cb39-123"><a href="#cb39-123" aria-hidden="true" tabindex="-1"></a>    capsize<span class="op">=</span><span class="fl">0.05</span>,</span>
<span id="cb39-124"><a href="#cb39-124" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span>custom_palette[<span class="st">"mda"</span>]</span>
<span id="cb39-125"><a href="#cb39-125" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb39-126"><a href="#cb39-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-127"><a href="#cb39-127" aria-hidden="true" tabindex="-1"></a><span class="co"># Title + axis</span></span>
<span id="cb39-128"><a href="#cb39-128" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"Directional Accuracy (MDA)</span><span class="ch">\n</span><span class="st">Higher is Better"</span>, fontsize<span class="op">=</span><span class="dv">14</span>, pad<span class="op">=</span><span class="dv">20</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb39-129"><a href="#cb39-129" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">"Model"</span>, labelpad<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb39-130"><a href="#cb39-130" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">"MDA Score"</span>, labelpad<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb39-131"><a href="#cb39-131" aria-hidden="true" tabindex="-1"></a>ax2.set_xticklabels(ax2.get_xticklabels(), rotation<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb39-132"><a href="#cb39-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-133"><a href="#cb39-133" aria-hidden="true" tabindex="-1"></a><span class="co"># Value labels</span></span>
<span id="cb39-134"><a href="#cb39-134" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> ax2.patches:</span>
<span id="cb39-135"><a href="#cb39-135" aria-hidden="true" tabindex="-1"></a>    height <span class="op">=</span> p.get_height()</span>
<span id="cb39-136"><a href="#cb39-136" aria-hidden="true" tabindex="-1"></a>    ax2.text(</span>
<span id="cb39-137"><a href="#cb39-137" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span>p.get_x() <span class="op">+</span> p.get_width() <span class="op">/</span> <span class="dv">2</span>,</span>
<span id="cb39-138"><a href="#cb39-138" aria-hidden="true" tabindex="-1"></a>        y<span class="op">=</span>height <span class="op">*</span> <span class="fl">1.01</span>,</span>
<span id="cb39-139"><a href="#cb39-139" aria-hidden="true" tabindex="-1"></a>        s<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>height<span class="sc">:.2%}</span><span class="ss">"</span>,</span>
<span id="cb39-140"><a href="#cb39-140" aria-hidden="true" tabindex="-1"></a>        ha<span class="op">=</span><span class="st">"center"</span>,</span>
<span id="cb39-141"><a href="#cb39-141" aria-hidden="true" tabindex="-1"></a>        va<span class="op">=</span><span class="st">"bottom"</span>,</span>
<span id="cb39-142"><a href="#cb39-142" aria-hidden="true" tabindex="-1"></a>        fontsize<span class="op">=</span><span class="dv">9</span></span>
<span id="cb39-143"><a href="#cb39-143" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb39-144"><a href="#cb39-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-145"><a href="#cb39-145" aria-hidden="true" tabindex="-1"></a><span class="co"># Highlight best MDA (highest)</span></span>
<span id="cb39-146"><a href="#cb39-146" aria-hidden="true" tabindex="-1"></a>best_val <span class="op">=</span> mda_df[<span class="st">"score"</span>].<span class="bu">max</span>()</span>
<span id="cb39-147"><a href="#cb39-147" aria-hidden="true" tabindex="-1"></a>best_model <span class="op">=</span> mda_df[mda_df[<span class="st">"score"</span>] <span class="op">==</span> best_val][<span class="st">"model"</span>].values[<span class="dv">0</span>]</span>
<span id="cb39-148"><a href="#cb39-148" aria-hidden="true" tabindex="-1"></a>x_pos <span class="op">=</span> model_order.index(best_model)</span>
<span id="cb39-149"><a href="#cb39-149" aria-hidden="true" tabindex="-1"></a>bar_width <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb39-150"><a href="#cb39-150" aria-hidden="true" tabindex="-1"></a>color <span class="op">=</span> <span class="st">"#b50505"</span></span>
<span id="cb39-151"><a href="#cb39-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-152"><a href="#cb39-152" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Glowing Marker ---</span></span>
<span id="cb39-153"><a href="#cb39-153" aria-hidden="true" tabindex="-1"></a>ax2.scatter(x<span class="op">=</span>x_pos, y<span class="op">=</span>best_val <span class="op">*</span><span class="fl">1.1</span>, s<span class="op">=</span><span class="dv">220</span>, color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.3</span>, zorder<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb39-154"><a href="#cb39-154" aria-hidden="true" tabindex="-1"></a>ax2.scatter(x<span class="op">=</span>x_pos, y<span class="op">=</span>best_val<span class="op">*</span><span class="fl">1.1</span>, s<span class="op">=</span><span class="dv">80</span>, color<span class="op">=</span>color, zorder<span class="op">=</span><span class="dv">6</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-155"><a href="#cb39-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-156"><a href="#cb39-156" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Floating Label ---</span></span>
<span id="cb39-157"><a href="#cb39-157" aria-hidden="true" tabindex="-1"></a>ax2.text(x_pos, best_val <span class="op">*</span> <span class="fl">1.15</span>, <span class="st">"Best MDA"</span>, fontsize<span class="op">=</span><span class="dv">10</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb39-158"><a href="#cb39-158" aria-hidden="true" tabindex="-1"></a>        ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>, color<span class="op">=</span>color, backgroundcolor<span class="op">=</span><span class="st">"white"</span>,</span>
<span id="cb39-159"><a href="#cb39-159" aria-hidden="true" tabindex="-1"></a>        bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">'round,pad=0.2'</span>, fc<span class="op">=</span><span class="st">'white'</span>, ec<span class="op">=</span>color, lw<span class="op">=</span><span class="fl">1.5</span>))</span>
<span id="cb39-160"><a href="#cb39-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-161"><a href="#cb39-161" aria-hidden="true" tabindex="-1"></a>sns.despine(ax<span class="op">=</span>ax2)</span>
<span id="cb39-162"><a href="#cb39-162" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Soft Glow Rectangle ---</span></span>
<span id="cb39-163"><a href="#cb39-163" aria-hidden="true" tabindex="-1"></a>ax2.add_patch(</span>
<span id="cb39-164"><a href="#cb39-164" aria-hidden="true" tabindex="-1"></a>    plt.Rectangle(</span>
<span id="cb39-165"><a href="#cb39-165" aria-hidden="true" tabindex="-1"></a>        (x_pos <span class="op">-</span> bar_width, <span class="dv">0</span>),  </span>
<span id="cb39-166"><a href="#cb39-166" aria-hidden="true" tabindex="-1"></a>        bar_width <span class="op">*</span> <span class="dv">2</span>,              </span>
<span id="cb39-167"><a href="#cb39-167" aria-hidden="true" tabindex="-1"></a>        ax2.get_ylim()[<span class="dv">1</span>],             </span>
<span id="cb39-168"><a href="#cb39-168" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span>color,</span>
<span id="cb39-169"><a href="#cb39-169" aria-hidden="true" tabindex="-1"></a>        alpha<span class="op">=</span><span class="fl">0.06</span>,                 </span>
<span id="cb39-170"><a href="#cb39-170" aria-hidden="true" tabindex="-1"></a>        zorder<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb39-171"><a href="#cb39-171" aria-hidden="true" tabindex="-1"></a>        linewidth<span class="op">=</span><span class="dv">0</span></span>
<span id="cb39-172"><a href="#cb39-172" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb39-173"><a href="#cb39-173" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb39-174"><a href="#cb39-174" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb39-175"><a href="#cb39-175" aria-hidden="true" tabindex="-1"></a>plt.figtext(<span class="fl">0.55</span>, <span class="op">-</span><span class="fl">0.1</span>, </span>
<span id="cb39-176"><a href="#cb39-176" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Figure 1: Model performance comparison showing error metrics (left) and directional accuracy (right).</span><span class="ch">\n</span><span class="st">"</span></span>
<span id="cb39-177"><a href="#cb39-177" aria-hidden="true" tabindex="-1"></a>           <span class="st">"EGARCH shows typical econometric performance while ML models demonstrate superior accuracy."</span>,</span>
<span id="cb39-178"><a href="#cb39-178" aria-hidden="true" tabindex="-1"></a>           ha<span class="op">=</span><span class="st">"center"</span>, fontsize<span class="op">=</span><span class="dv">10</span>, style<span class="op">=</span><span class="st">"italic"</span>)</span>
<span id="cb39-179"><a href="#cb39-179" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Final_group_report_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="66ac5aa9" class="cell" data-execution_count="27">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(plt.style.available)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>['Solarize_Light2', '_classic_test_patch', '_mpl-gallery', '_mpl-gallery-nogrid', 'bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'petroff10', 'seaborn-v0_8', 'seaborn-v0_8-bright', 'seaborn-v0_8-colorblind', 'seaborn-v0_8-dark', 'seaborn-v0_8-dark-palette', 'seaborn-v0_8-darkgrid', 'seaborn-v0_8-deep', 'seaborn-v0_8-muted', 'seaborn-v0_8-notebook', 'seaborn-v0_8-paper', 'seaborn-v0_8-pastel', 'seaborn-v0_8-poster', 'seaborn-v0_8-talk', 'seaborn-v0_8-ticks', 'seaborn-v0_8-white', 'seaborn-v0_8-whitegrid', 'tableau-colorblind10']</code></pre>
</div>
</div>
<div id="b962cd2e" class="cell" data-scrolled="true" data-execution_count="28">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Prepare data</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>df_time <span class="op">=</span> avg_metrics_df[[<span class="st">'model'</span>, <span class="st">'prediction_time'</span>]].copy()</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>df_time[<span class="st">'relative_to_egarch'</span>] <span class="op">=</span> df_time[<span class="st">'prediction_time'</span>] <span class="op">/</span> df_time[df_time[<span class="st">'model'</span>] <span class="op">==</span> <span class="st">'egarch'</span>][<span class="st">'prediction_time'</span>].values[<span class="dv">0</span>]</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>df_time[<span class="st">'relative_to_egarch'</span>] <span class="op">=</span> df_time[<span class="st">'relative_to_egarch'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="ss">f"</span><span class="sc">{</span>x<span class="sc">:.2f}</span><span class="ss">x"</span>)</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>df_time[<span class="st">'prediction_time'</span>] <span class="op">=</span> df_time[<span class="st">'prediction_time'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="ss">f"</span><span class="sc">{</span>x<span class="sc">:.2f}</span><span class="ss">s"</span>)</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort by prediction time for visual clarity</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>df_time <span class="op">=</span> df_time.sort_values(<span class="st">'prediction_time'</span>)</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Stylish plotly table</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> go.Figure(data<span class="op">=</span>[go.Table(</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    header<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>        values<span class="op">=</span>[<span class="st">"&lt;b&gt;Model&lt;/b&gt;"</span>, <span class="st">"&lt;b&gt;Prediction Time&lt;/b&gt;"</span>, <span class="st">"&lt;b&gt;Relative to EGARCH&lt;/b&gt;"</span>],</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>        fill_color<span class="op">=</span><span class="st">'#003366'</span>,</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        font<span class="op">=</span><span class="bu">dict</span>(color<span class="op">=</span><span class="st">'white'</span>, size<span class="op">=</span><span class="dv">12</span>),</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>        align<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>        height<span class="op">=</span><span class="dv">35</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    cells<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>        values<span class="op">=</span>[</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>            df_time[<span class="st">'model'</span>],</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>            df_time[<span class="st">'prediction_time'</span>],</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>            df_time[<span class="st">'relative_to_egarch'</span>]</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>        ],</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>        fill_color<span class="op">=</span>[[<span class="st">'#ededed'</span>] <span class="op">*</span> <span class="bu">len</span>(df_time)],  </span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>        align<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>        height<span class="op">=</span><span class="dv">30</span>,</span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>        font<span class="op">=</span><span class="bu">dict</span>(size<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>)])</span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>fig.update_layout(</span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>    title_text<span class="op">=</span><span class="st">"⏱️ Prediction Time Comparison by Model"</span>,</span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>    title_font_size<span class="op">=</span><span class="dv">16</span>,</span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>    title_x<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>    margin<span class="op">=</span><span class="bu">dict</span>(l<span class="op">=</span><span class="dv">20</span>, r<span class="op">=</span><span class="dv">20</span>, t<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a>fig.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<pre><code>Unable to display output for mime type(s): application/vnd.plotly.v1+json</code></pre>
</div>
</div>
</section>
<section id="hyperparameter-tuning" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="hyperparameter-tuning"><span class="header-section-number">9</span> Hyperparameter Tuning</h2>
<p>Having shown that the LightGBM model significantly outperformed both the EGARCH benchmark and other machine learning baselines, we proceed to refine its permformance through systematic hyperparameter tuning. The goal was not only to maximise predictive accuracy but also to improve. model generalisation across volatile market conditions.</p>
<p>To achieve this, we developed a robust and time-aware tuning pipeline comining three core components:</p>
<ol type="1">
<li><code>TimeSeriesSplit</code> Cross Validation</li>
</ol>
<p>When working with financial time series, preserving the temporal structure of data is essential. Standard k-fold cross-validation risks data leakage by randomly shuffling past and future observations, which leads to overly optimistic performance estimates.</p>
<p>To address this, we used <code>TimeSeriesSplit</code>, a time-respecting validation method that maintains chronological order within each fold. This ensures that the model is always trained on the past and validated on the future—replicating real-world forecasting conditions and preventing information leakage.</p>
<ol start="2" type="1">
<li>Efficient Hyperparameter Optimisation with <code>optuna</code></li>
</ol>
<p>LightGBM includes many hyperparameters that interact non-linearly. Rather than rely on exhaustive grid or naie random search— which are computationally expensive and inefficient—we adopted Optuna, a state-of-the-art optimisation framework based on Bayesian search via the Tree-structure Parzen Estimator (TPE).</p>
<p>Key advantages of this approach:</p>
<ul>
<li><p>Sample-efficient search: Learns from previous trials to prioritise promising regions of the hyperparameter space.</p></li>
<li><p>Early stopping: Prunes unpromising trials to reduce wasted computation.</p></li>
<li><p>Parallel-friendly: Scales well for multiple trials, enabling faster convergence.</p></li>
</ul>
<p>We tuned the following critical hyperparameters: * Model complexity: <code>num_leaves</code>, <code>max_depth</code> * Regularisation: <code>lambda_l1</code>, <code>lambda_l2</code>, <code>min_data_in_leaf</code> * Learning dynamics: <code>learning_rate</code>, <code>feature_fraction</code>, <code>bagging_fraction</code>.</p>
<ol start="3" type="1">
<li>Stable Evaluation via RMSE averaging</li>
</ol>
<p>Each trial’s performance was measure using RMSE, averaged across five time-ordered validation folds. This reduces sensitivity to any single volatile interval and provides a more robust estimate of real-world forecasting performance.</p>
<div id="5621fb66" class="cell" data-scrolled="true" data-results="hide" data-stdout="false" data-execution_count="29">
<details class="code-fold">
<summary>Click to expand this code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use time-series-aware cross validation</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>X_all, y_all <span class="op">=</span> [], []</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (stock, time_id), df_subset <span class="kw">in</span> df_general.groupby([<span class="st">'stock_name'</span>, <span class="st">'time_id'</span>]):</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> df_subset.copy()</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'WAP'</span>] <span class="op">=</span> compute_wap(df)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'log_ret'</span>] <span class="op">=</span> compute_log_returns(df[<span class="st">'WAP'</span>])</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> engineer_features(df)</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>        feature_cols <span class="op">=</span> [<span class="ss">f'log_ret_std_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'wap_lag_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'wap_delta_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>        [<span class="st">'wap_trend_5s'</span>] <span class="op">+</span> [<span class="st">'spread'</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'spread_lag_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'spread_delta_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>        [<span class="st">'liquidity_shock'</span>, <span class="st">'imbalance_velocity'</span>, <span class="st">'vol_weighted_vol'</span>, <span class="st">'noise_ratio'</span>, <span class="st">'hidden_liquidity'</span>]</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>        X_train, y_train, <span class="op">*</span>_ <span class="op">=</span> split_data(df, feature_cols)</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>        X_all.append(X_train)</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>        y_all.append(y_train)</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>X_train_all <span class="op">=</span> pd.concat(X_all).sort_index()</span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>y_train_all <span class="op">=</span> pd.concat(y_all).sort_index()</span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(trial):</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> {</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>        <span class="st">'objective'</span>: <span class="st">'regression'</span>,</span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>        <span class="st">'metric'</span>: <span class="st">'rmse'</span>,</span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>        <span class="st">'verbosity'</span>: <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a>        <span class="st">'boosting_type'</span>: <span class="st">'gbdt'</span>,</span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a>        <span class="st">'num_leaves'</span>: trial.suggest_categorical(<span class="st">'num_leaves'</span>, [<span class="dv">20</span>, <span class="dv">31</span>, <span class="dv">40</span>, <span class="dv">50</span>]),</span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>        <span class="st">'max_depth'</span>: trial.suggest_int(<span class="st">'max_depth'</span>, <span class="dv">3</span>, <span class="dv">7</span>),</span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a>        <span class="st">'learning_rate'</span>: trial.suggest_float(<span class="st">'learning_rate'</span>, <span class="fl">0.01</span>, <span class="fl">0.05</span>, step<span class="op">=</span><span class="fl">0.01</span>),</span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a>        <span class="st">'feature_fraction'</span>: trial.suggest_float(<span class="st">'feature_fraction'</span>, <span class="fl">0.7</span>, <span class="fl">1.0</span>, step<span class="op">=</span><span class="fl">0.1</span>),</span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a>        <span class="st">'bagging_fraction'</span>: trial.suggest_float(<span class="st">'bagging_fraction'</span>, <span class="fl">0.7</span>, <span class="fl">1.0</span>, step<span class="op">=</span><span class="fl">0.1</span>),</span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a>        <span class="st">'min_data_in_leaf'</span>: trial.suggest_int(<span class="st">'min_data_in_leaf'</span>, <span class="dv">20</span>, <span class="dv">60</span>, step<span class="op">=</span><span class="dv">10</span>),</span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a>        <span class="st">'lambda_l1'</span>: trial.suggest_float(<span class="st">'lambda_l1'</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, step<span class="op">=</span><span class="fl">0.1</span>),</span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true" tabindex="-1"></a>        <span class="st">'lambda_l2'</span>: trial.suggest_float(<span class="st">'lambda_l2'</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, step<span class="op">=</span><span class="fl">0.1</span>),</span>
<span id="cb44-39"><a href="#cb44-39" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb44-40"><a href="#cb44-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-41"><a href="#cb44-41" aria-hidden="true" tabindex="-1"></a>    tscv <span class="op">=</span> TimeSeriesSplit(n_splits<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb44-42"><a href="#cb44-42" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> []</span>
<span id="cb44-43"><a href="#cb44-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> train_idx, val_idx <span class="kw">in</span> tscv.split(X_train_all):</span>
<span id="cb44-44"><a href="#cb44-44" aria-hidden="true" tabindex="-1"></a>        X_t, X_v <span class="op">=</span> X_train_all.iloc[train_idx], X_train_all.iloc[val_idx]</span>
<span id="cb44-45"><a href="#cb44-45" aria-hidden="true" tabindex="-1"></a>        y_t, y_v <span class="op">=</span> y_train_all.iloc[train_idx], y_train_all.iloc[val_idx]</span>
<span id="cb44-46"><a href="#cb44-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-47"><a href="#cb44-47" aria-hidden="true" tabindex="-1"></a>        lgb_train <span class="op">=</span> lgb.Dataset(X_t, y_t)</span>
<span id="cb44-48"><a href="#cb44-48" aria-hidden="true" tabindex="-1"></a>        lgb_valid <span class="op">=</span> lgb.Dataset(X_v, y_v, reference<span class="op">=</span>lgb_train)</span>
<span id="cb44-49"><a href="#cb44-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-50"><a href="#cb44-50" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> lgb.train(</span>
<span id="cb44-51"><a href="#cb44-51" aria-hidden="true" tabindex="-1"></a>            params,</span>
<span id="cb44-52"><a href="#cb44-52" aria-hidden="true" tabindex="-1"></a>            lgb_train,</span>
<span id="cb44-53"><a href="#cb44-53" aria-hidden="true" tabindex="-1"></a>            valid_sets<span class="op">=</span>[lgb_valid],</span>
<span id="cb44-54"><a href="#cb44-54" aria-hidden="true" tabindex="-1"></a>            num_boost_round<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb44-55"><a href="#cb44-55" aria-hidden="true" tabindex="-1"></a>            callbacks<span class="op">=</span>[lgb.early_stopping(<span class="dv">20</span>), lgb.log_evaluation(<span class="dv">0</span>)])</span>
<span id="cb44-56"><a href="#cb44-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-57"><a href="#cb44-57" aria-hidden="true" tabindex="-1"></a>        y_pred <span class="op">=</span> model.predict(X_v, num_iteration<span class="op">=</span>model.best_iteration)</span>
<span id="cb44-58"><a href="#cb44-58" aria-hidden="true" tabindex="-1"></a>        score <span class="op">=</span> np.sqrt(mean_squared_error(y_v, y_pred))</span>
<span id="cb44-59"><a href="#cb44-59" aria-hidden="true" tabindex="-1"></a>        scores.append(score)</span>
<span id="cb44-60"><a href="#cb44-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-61"><a href="#cb44-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(scores)</span>
<span id="cb44-62"><a href="#cb44-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-63"><a href="#cb44-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Set seed for reproducibility</span></span>
<span id="cb44-64"><a href="#cb44-64" aria-hidden="true" tabindex="-1"></a>study <span class="op">=</span> optuna.create_study(direction<span class="op">=</span><span class="st">'minimize'</span>, sampler<span class="op">=</span>optuna.samplers.TPESampler(seed<span class="op">=</span><span class="dv">42</span>))</span>
<span id="cb44-65"><a href="#cb44-65" aria-hidden="true" tabindex="-1"></a>study.optimize(objective, n_trials<span class="op">=</span><span class="dv">50</span>, show_progress_bar<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="ed9ae6a3" class="cell" data-scrolled="true" data-execution_count="30">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best parameters:"</span>, study.best_params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Best parameters: {'num_leaves': 40, 'max_depth': 6, 'learning_rate': 0.05, 'feature_fraction': 1.0, 'bagging_fraction': 0.7999999999999999, 'min_data_in_leaf': 30, 'lambda_l1': 0.0, 'lambda_l2': 0.9}</code></pre>
</div>
</div>
</section>
<section id="feature-selection" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="feature-selection"><span class="header-section-number">10</span> Feature Selection</h2>
<p>After optimizing the model with Optuna, we trained a final LightGBM model on the entire training set using the best parameters. SHAP (SHaply Additive exPlanations) values were computed for all features to assess their relative contribution to model predictions. The top-ranked features by mean absolute SHAP value were then considered for further model refinement and selection.</p>
<p>Figure 3 presents the top ten features ranked by their mean absolute SHAP values, which quantify average marginal impact on model output. The analysis reveals a clear hierarchy of feature importance, with a pronounced dominance of ultra-short-term order flow dynamics.</p>
<p>The clear standout feature, <code>wap_delta_1</code>, dominates with a mean |SHAP| value an order of magnitude larger than the next most impactful feature. This reflects the extreme sensitivity of the model to instantaneous changes in the volume-weighted average price (WAP), consistent with theoretical expectations in high-frequency markets where price direction is often dictated by the most recent order flow movements.</p>
<p>The prominence of successive wap_delta_k terms (for <span class="math inline">\(k=2,3,4,5\)</span>) underscores the model’s ability to synthesize local price velocity and curvature over multiple microsecond intervals. Collectively, these features capture short-term price momentum and acceleration, which are critical for forecasting transient volatility spikes.</p>
<p>Interestingly, the second most important feature, <code>vol_weighted_vol</code>, integrates log return magnitudes with contemporaneous bid-side liquidity, approximating a liquidity-weighted realized volatility proxy. Its impact—although far below <code>wap_delta_1</code>—signals that volume context matters, especially under liquidity stress or during informed trading activity.</p>
<p><code>Noise_ratio</code>, which contrasts quote dispersion with rolling WAP variance, ranks sixth. This supports the hypothesis that informational noise and quote instability play a nontrivial role in anticipating volatility bursts, particularly in the presence of jittery market depth.</p>
<p>Lower-ranked features like <code>wap_lag_1</code> and <code>spread_delta_1</code> capture lagged price anchoring and cross-side pressure asymmetries. Their relatively lower SHAP contributions suggest that while these features encode useful supplementary context, they are not primary drivers of volatility in the high-frequency regime compared to immediate price derivatives.</p>
<div id="22c37987" class="cell" data-scrolled="true" data-execution_count="31">
<details class="code-fold">
<summary>Click to expand this code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Final model fit using best parameters</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>best_params <span class="op">=</span> study.best_params</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>best_params.update({<span class="st">'objective'</span>: <span class="st">'regression'</span>, <span class="st">'metric'</span>: <span class="st">'rmse'</span>, <span class="st">'verbosity'</span>: <span class="op">-</span><span class="dv">1</span>})</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Final model fit on all data (no early stopping)</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> lgb.train(</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    best_params,</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    lgb.Dataset(X_train_all, label<span class="op">=</span>y_train_all),</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    num_boost_round<span class="op">=</span><span class="dv">300</span>, </span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    callbacks<span class="op">=</span>[lgb.log_evaluation(<span class="dv">0</span>)]</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a><span class="co"># SHAP Analysis</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>explainer <span class="op">=</span> shap.Explainer(model)</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>shap_values <span class="op">=</span> explainer(X_train_all)</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>shap_df <span class="op">=</span> pd.DataFrame(shap_values.values, columns<span class="op">=</span>feature_cols)</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>shap_mean <span class="op">=</span> shap_df.<span class="bu">abs</span>().mean().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="3f1b832c" class="cell" data-execution_count="32">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.express <span class="im">as</span> px</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to DataFrame to ensure proper sorting</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>top_10_df <span class="op">=</span> shap_mean.sort_values(ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>).to_frame(name<span class="op">=</span><span class="st">'mean_abs_shap'</span>)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>top_10_df <span class="op">=</span> top_10_df[::<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Reverse to have most important at the top (horizontal bar)</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>bars <span class="op">=</span> ax.barh(top_10_df.index, top_10_df[<span class="st">'mean_abs_shap'</span>], color<span class="op">=</span><span class="st">"#003366"</span>)</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Add text at the end of bars</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>offset <span class="op">=</span> top_10_df[<span class="st">'mean_abs_shap'</span>].<span class="bu">max</span>() <span class="op">*</span> <span class="fl">0.02</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> bar, value <span class="kw">in</span> <span class="bu">zip</span>(bars, top_10_df[<span class="st">'mean_abs_shap'</span>]):</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    ax.text(bar.get_width() <span class="op">+</span> offset, bar.get_y() <span class="op">+</span> bar.get_height()<span class="op">/</span><span class="dv">2</span>,</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f"</span><span class="sc">{</span>value<span class="sc">:.2e}</span><span class="ss">"</span>, va<span class="op">=</span><span class="st">'center'</span>, ha<span class="op">=</span><span class="st">'left'</span>, fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Style</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Top 10 Most Important Features (SHAP)'</span>, fontsize<span class="op">=</span><span class="dv">16</span>, weight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'Mean |SHAP value|'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Feature'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>ax.set_facecolor(<span class="st">'white'</span>)</span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>ax.grid(axis<span class="op">=</span><span class="st">'x'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'lightgray'</span>)</span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>ax.spines[[<span class="st">'top'</span>, <span class="st">'right'</span>]].set_visible(<span class="va">False</span>)</span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Final_group_report_files/figure-html/cell-21-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="robustness-check-and-generalisability" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="robustness-check-and-generalisability"><span class="header-section-number">11</span> Robustness Check and Generalisability</h2>
<p>To assess the robustness of our model, we conducted a targeted generalisability test by applying the final tuned LightGBM model to two disjoint subsets created initially: <code>df_high</code>, representing periods of elevated volatility, and <code>df_low</code>, capturing calmer market conditions. The model retained strong predictive performance on <code>df_low</code>, with RMSE and MAE metrics even outperforming those observed on the general dataset (see Appendix). This affirms the model’s ability to capture noise-adjusted dynamics in stable conditions through refined order book features such as WAP trend, bid-ask deltas, and imbalance velocity.</p>
<p>However, on <code>df_high</code>, performance metrics deteriorated notably. This decline may stem from the heightened structural complexity and non-stationarity present during volatility spikes, which challenge fixed-parameter models and amplify the effects of latency, rapid order flow shifts, and temporary liquidity dislocations. These conditions could introduce patterns not well captured by features or parameter choices tuned on the broader dataset.</p>
<p>Nonetheless, the discrepancy does not diminish the model’s value for deployment within our target application. In practice, such models would be integrated within broader real-time systems that can trigger conservative responses or adapt thresholds during extreme regimes. While further work is warranted to enhance adaptability under high-volatility stress, the model’s core architecture remains well-suited for production, particularly in environments dominated by low- to moderate-volatility periods.</p>
</section>
<section id="appendix" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="appendix"><span class="header-section-number">12</span> Appendix</h2>
<div id="6ac93852" class="cell" data-results="hide" data-message="false" data-stdout="false" data-execution_count="33">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Code for Robustness check of final model</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> final_model_pipeline(df_input):</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    generalisability_metrics <span class="op">=</span> []</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (stock, time_id), df_subset <span class="kw">in</span> df_input.groupby([<span class="st">'stock_name'</span>, <span class="st">'time_id'</span>]):</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> df_subset.copy()</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'WAP'</span>] <span class="op">=</span> compute_wap(df)</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'log_ret'</span>] <span class="op">=</span> compute_log_returns(df[<span class="st">'WAP'</span>])</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Features selected through SHAP analysis</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> lag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>):</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'wap_lag_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> df[<span class="st">'WAP'</span>].shift(lag)</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'wap_delta_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> df[<span class="st">'WAP'</span>] <span class="op">-</span> df[<span class="ss">f'wap_lag_</span><span class="sc">{</span>lag<span class="sc">}</span><span class="ss">'</span>]</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'wap_trend_5s'</span>] <span class="op">=</span> df[[<span class="ss">f'wap_delta_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)]].mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'vol_weighted_vol'</span>] <span class="op">=</span> df[<span class="st">'log_ret'</span>].<span class="bu">abs</span>() <span class="op">*</span> df[<span class="st">'bid_size1'</span>].rolling(<span class="dv">10</span>).<span class="bu">sum</span>()</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'noise_ratio'</span>] <span class="op">=</span> df[<span class="st">'ask_price1'</span>].diff().<span class="bu">abs</span>() <span class="op">/</span> df[<span class="st">'WAP'</span>].diff().<span class="bu">abs</span>().rolling(<span class="dv">5</span>).std()</span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'spread'</span>] <span class="op">=</span> (df[<span class="st">'ask_price1'</span>] <span class="op">-</span> df[<span class="st">'bid_price1'</span>]) <span class="op">/</span> df[<span class="st">'ask_price1'</span>]</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'spread_lag_1'</span>] <span class="op">=</span> df[<span class="st">'spread'</span>].shift(<span class="dv">1</span>)</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'spread_delta_1'</span>] <span class="op">=</span> df[<span class="st">'spread'</span>] <span class="op">-</span> df[<span class="ss">f'spread_lag_1'</span>]</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>        feature_cols <span class="op">=</span> [<span class="st">'wap_lag_1'</span>, <span class="st">'wap_trend_5s'</span>, <span class="st">'spread_delta_1'</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>        [<span class="ss">f'wap_delta_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>)] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>        [<span class="st">'vol_weighted_vol'</span>, <span class="st">'noise_ratio'</span>]</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Split</span></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>            X_train, y_train, X_val, y_val, X_test, y_test, test_df <span class="op">=</span> split_data(df, feature_cols)</span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(X_train) <span class="op">&lt;</span> <span class="dv">10</span> <span class="kw">or</span> <span class="bu">len</span>(X_test) <span class="op">&lt;</span> <span class="dv">10</span>:</span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Train</span></span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>            train_set <span class="op">=</span> lgb.Dataset(X_train, label<span class="op">=</span>y_train)</span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>            val_set <span class="op">=</span> lgb.Dataset(X_val, label<span class="op">=</span>y_val)</span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>            model <span class="op">=</span> lgb.train(best_params, train_set, num_boost_round<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>                              valid_sets<span class="op">=</span>[val_set], </span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>                              callbacks<span class="op">=</span>[lgb.early_stopping(<span class="dv">20</span>), lgb.log_evaluation(<span class="dv">0</span>)])</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>            y_pred <span class="op">=</span> model.predict(X_test)</span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>            results_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>                <span class="st">'time_id'</span>: time_id,</span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>                <span class="st">'seconds_in_bucket'</span>: test_df[<span class="st">'seconds_in_bucket'</span>].values,</span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>                <span class="st">'y_true'</span>: y_test,</span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>                <span class="st">'y_pred'</span>: y_pred</span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>            })</span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>            full_range <span class="op">=</span> pd.DataFrame({<span class="st">'seconds_in_bucket'</span>: np.arange(<span class="dv">480</span>, <span class="dv">600</span>)})</span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a>            results_df_filled <span class="op">=</span> pd.merge(full_range, results_df, on<span class="op">=</span><span class="st">'seconds_in_bucket'</span>, how<span class="op">=</span><span class="st">'left'</span>).fillna(<span class="dv">0</span>)</span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>            results_df_filled[<span class="st">'time_bucket'</span>] <span class="op">=</span> (results_df_filled[<span class="st">'seconds_in_bucket'</span>] <span class="op">-</span> <span class="dv">480</span>) <span class="op">//</span> <span class="dv">20</span></span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a>            actual_rv <span class="op">=</span> results_df_filled.groupby(<span class="st">'time_bucket'</span>)[<span class="st">'y_true'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: np.sqrt(np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb49-53"><a href="#cb49-53" aria-hidden="true" tabindex="-1"></a>            pred_rv <span class="op">=</span> results_df_filled.groupby(<span class="st">'time_bucket'</span>)[<span class="st">'y_pred'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: np.sqrt(np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb49-54"><a href="#cb49-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-55"><a href="#cb49-55" aria-hidden="true" tabindex="-1"></a>            rmse <span class="op">=</span> np.sqrt(mean_squared_error(actual_rv, pred_rv))</span>
<span id="cb49-56"><a href="#cb49-56" aria-hidden="true" tabindex="-1"></a>            mae <span class="op">=</span> mean_absolute_error(actual_rv, pred_rv)</span>
<span id="cb49-57"><a href="#cb49-57" aria-hidden="true" tabindex="-1"></a>            mda <span class="op">=</span> calculate_mda(actual_rv.values, pred_rv.values)</span>
<span id="cb49-58"><a href="#cb49-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-59"><a href="#cb49-59" aria-hidden="true" tabindex="-1"></a>            generalisability_metrics.append({</span>
<span id="cb49-60"><a href="#cb49-60" aria-hidden="true" tabindex="-1"></a>                <span class="st">'time_id'</span>: time_id,</span>
<span id="cb49-61"><a href="#cb49-61" aria-hidden="true" tabindex="-1"></a>                <span class="st">'rmse'</span>: rmse,</span>
<span id="cb49-62"><a href="#cb49-62" aria-hidden="true" tabindex="-1"></a>                <span class="st">'mae'</span>: mae,</span>
<span id="cb49-63"><a href="#cb49-63" aria-hidden="true" tabindex="-1"></a>                <span class="st">'mda'</span>: mda</span>
<span id="cb49-64"><a href="#cb49-64" aria-hidden="true" tabindex="-1"></a>            })</span>
<span id="cb49-65"><a href="#cb49-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb49-66"><a href="#cb49-66" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Error in time_id </span><span class="sc">{</span>time_id<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb49-67"><a href="#cb49-67" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb49-68"><a href="#cb49-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-69"><a href="#cb49-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(generalisability_metrics)</span>
<span id="cb49-70"><a href="#cb49-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-71"><a href="#cb49-71" aria-hidden="true" tabindex="-1"></a>high_vol_metrics <span class="op">=</span> final_model_pipeline(df_high)</span>
<span id="cb49-72"><a href="#cb49-72" aria-hidden="true" tabindex="-1"></a>low_vol_metrics <span class="op">=</span> final_model_pipeline(df_low)</span>
<span id="cb49-73"><a href="#cb49-73" aria-hidden="true" tabindex="-1"></a>high_summary <span class="op">=</span> high_vol_metrics[[<span class="st">'rmse'</span>, <span class="st">'mae'</span>, <span class="st">'mda'</span>]].mean().to_frame(name<span class="op">=</span><span class="st">'High Volatility'</span>)</span>
<span id="cb49-74"><a href="#cb49-74" aria-hidden="true" tabindex="-1"></a>low_summary <span class="op">=</span> low_vol_metrics[[<span class="st">'rmse'</span>, <span class="st">'mae'</span>, <span class="st">'mda'</span>]].mean().to_frame(name<span class="op">=</span><span class="st">'Low Volatility'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>